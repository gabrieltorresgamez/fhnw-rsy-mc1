---
title: "RSY: MC1"
subtitle: "Studiengang Data Science (HS2022), FHNW"
author: "Jan Zwicky und Gabriel Torres"
date: "Letzte Aktualisierungen: `r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::html_document2:
      code_folding: show
      toc: true
      toc_depth: 3
      toc_float: true
      number_sections: true
editor_options: 
  chunk_output_type: console
---
<style>
#TOC {
  background-color: #F5F5F5;
  font-size: 16px;
}
#header{
  color: #708090;
  background-color: #F5F5F5;
  font-size: 30px;
}
body{
  color: #708090;
  background-color:#F5F5F5;
}
</style>

# Aufgabenstellung


# Daten aufbereiten und Pakete Lesen
## Pakete laden und Daten einlesen
### Pakete laden
```{r setup, cache = TRUE, message = FALSE, warning = FALSE}
# Pakete für Data wrangling und Visualisierung
library(tidyverse)

# Pakete für das HTML
library(bookdown)
library(knitr)

# Recommenderlab
library(recommenderlab)

# Coop
library(coop)

# Vegan
library(vegan)

# Latent Semantic Analysis
library(lsa)

```
###  Konfiguration
```{r}
# Konfiguration der Pakete
knitr::opts_chunk$set(fit.align = "left", cache = TRUE, warning = FALSE, message = FALSE)
set.seed(100)
```
### Daten einlesen
```{r}
# Einlesen der CSV-Dateien und erstellen der samples
movies <- read.csv("ml-latest-small/movies.csv", sep = ",")
links <- read.csv("ml-latest-small/links.csv", sep = ",")
ratings <- read.csv("ml-latest-small/ratings.csv", sep = ",")
tags <- read.csv("ml-latest-small/tags.csv", sep = ",")

# Sample von 70%
set.seed(69)
movies2 <- movies %>% slice_sample(prop = 0.7)
links2 <- subset(links, movieId %in% movies2$movieId)
ratings2 <- subset(ratings, movieId %in% movies2$movieId) %>% slice_sample(prop = 0.7)
tags2 <- subset(tags, movieId %in% movies2$movieId)

# 2ter Sample von 70%
set.seed(100)
movies <- movies %>% slice_sample(prop = 0.7)
links <- subset(links, movieId %in% movies$movieId)
ratings <- subset(ratings, movieId %in% movies$movieId) %>% slice_sample(prop = 0.7)
tags <- subset(tags, movieId %in% movies$movieId)
```

# Implementierung
## Berechnung der cosinus/jaccard similarity
```{r}
calculate_jaccard <- function(arr1, arr2) {
  # Check which columns are available
  vals <- (!is.na(array(arr1)) & !is.na(array(arr2)))
  # Remove movieId column from jaccard similarity
  vals[1] <- FALSE
  # If there are common not na values, calculate jac sim
  if (sum(vals) != 0) {
    both_true <- arr1[vals] & arr2[vals]
    either_true <- arr1[vals] | arr2[vals]
    jac_sim <- sum(both_true) / sum(either_true)
    return(jac_sim)
  }
  # If not, return NA
  return(NA)
}

calculate_cos <- function(arr1, arr2) {
  # Check which columns are available
  vals <- (!is.na(array(arr1)) & !is.na(array(arr2)))
  # Remove movieId column from cos similarity
  vals[1] <- FALSE
  # If there are common not na values, calculate cos sim
  if (sum(vals) != 0) {
    cos_sim <- lsa::cosine(arr1[vals], arr2[vals])
    return(cos_sim)
  }
  # If not, return NA
  return(NA)
}
```

## Berechnung der Ähnlichkeitsmatrix
```{r}
getCorrelationMatrix <- function(data, cos = TRUE) {
  # Get array with movieId's
  movies <- as.character(data$movieId)

  # Create correlation matrix and set diag to 1
  correlations <- matrix(
    NA,
    nrow = length(movies),
    ncol = length(movies),
    dimnames = list(movies, movies)
  )
  diag(correlations) <- 1

  # Iterate through every movie and preload column
  i_counter <- 0
  for (i in movies) {
    i_counter <- i_counter + 1
    row_i <- data %>% filter(movieId == i)
    # For every movie, iterate through every movie
    j_counter <- 0
    for (j in movies) {
      j_counter <- j_counter + 1
      # If cos similarity was already calculated, skip, else continue
      if (i_counter <= j_counter) {
        # calculate similarity
        row_j <- data %>% filter(movieId == j)
        if (cos) {
          sim <- calculate_cos(row_i, row_j)
        } else {
          sim <- calculate_jaccard(row_i, row_j)
        }
        # set sim in sim matrix
        correlations[i, j] <- sim
        correlations[j, i] <- sim
      }
    }
    # Track progress
    # print(paste(i_counter, " Datasets done"))
  }
  # Return correlation matrix
  return(correlations)
}
```

## Test der Funktionen
```{r}
# Erstellung der User-Rating Matrix
set.seed(100)
sample_values <- sample(1:6819, 300, replace = FALSE)

norm_ratings <- ratings %>%
  group_by(userId) %>%
  summarise(mean_rating = mean(rating), sd_rating = sd(rating)) %>%
  full_join(., ratings, by = "userId")

norm_ratings$z_rating <- (norm_ratings$rating - norm_ratings$mean_rating) /
  norm_ratings$sd_rating

item_user_random_100 <- norm_ratings %>%
  select(movieId, userId, z_rating) %>%
  pivot_wider(names_from = userId, values_from = z_rating) %>%
  filter(movieId %in% sample_values) %>%
  head(100)

numToBool <- function(x) (x >= 0)
item_user_random_100_bool <- item_user_random_100 %>% mutate(across(!matches("movieId"), numToBool))
```

```{r}
# Erstellung der User-Rating Like-Dislike Matrix

corrNumb <- getCorrelationMatrix(item_user_random_100, cos = TRUE)
corrBool <- getCorrelationMatrix(item_user_random_100_bool, cos = FALSE)
```

## Vergleich mit recommenderlabs
```{r}
item_user_random_100_recommenderlab <- item_user_random_100 %>%
  column_to_rownames(., var = "movieId") %>%
  as.matrix(.) %>%
  t(.)

corrNumbRL <- as.matrix(similarity(as(item_user_random_100_recommenderlab, "realRatingMatrix"), method = "cosine", which = "items"))

corrNumbRL[1:6,1:6]
corrNumb[1:6,1:6]
```

```{r}
item_user_random_100_bool_recommenderlab <- item_user_random_100_bool %>%
  column_to_rownames(., var = "movieId") %>%
  t(.)

corrBoolRL <- as.matrix(similarity(as(item_user_random_100_bool_recommenderlab, "realRatingMatrix"), method = "jaccard", which = "items"))

corrBoolRL[1:6,1:6]
corrBool[1:6,1:6]
```

## Vergleich mit coop (cosine) und vegan (jaccard)
```{r}
corrNumbC <- coop::cosine(item_user_random_100_recommenderlab, use = "everything")

corrNumbC[1:6,1:6]
corrNumb[1:6,1:6]
```

```{r}
corrBoolVG <- vegdist(item_user_random_100_bool_recommenderlab %>% t(.), method = "jaccard", na.rm = TRUE) %>% 
  as.matrix(.)

corrBoolVG[1:6,1:6]
corrBool[1:6,1:6]

```

## Vergleich der Korrelationsmatrizen

Die Korrelationsmatrix mit ordinalen Ratings scheint viel detailliertere Korrelationswerte 
zurückzugeben, da wir genaue Ratings der User haben. Da mit der Umwandlung zu binären 
Werten diese Informationen verloren gehen, sieht die Korrelationsmatrix mit binären Werten 
dementsprechend weniger hochauflösend aus.
