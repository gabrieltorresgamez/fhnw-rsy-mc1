---
title: "RSY: MC1"
subtitle: "Studiengang Data Science (HS2022), FHNW"
author: "Jan Zwicky und Gabriel Torres"
date: "Letzte Aktualisierungen: `r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::html_document2:
      code_folding: show
      toc: true
      toc_depth: 3
      toc_float: true
      number_sections: true
editor_options: 
  chunk_output_type: console
---
<style>
#TOC {
  background-color: #F5F5F5;
  font-size: 16px;
}
#header{
  color: #708090;
  background-color: #F5F5F5;
  font-size: 30px;
}
body{
  color: #708090;
  background-color:#F5F5F5;
}
</style>

# Aufgabenstellung


# Daten aufbereiten und Pakete Lesen
## Pakete laden und Daten einlesen
### Pakete laden
```{r setup, cache = TRUE, message = FALSE, warning = FALSE}
# Pakete für Data wrangling und Visualisierung
library(tidyverse)

# Pakete für das HTML
library(bookdown)
library(knitr)

# Recommenderlab
library(recommenderlab)

# Latent Semantic Analysis
library(lsa)
```
###  Konfiguration
```{r}
# Konfiguration der Pakete
knitr::opts_chunk$set(fit.align = "left", cache = TRUE, warning = FALSE, message = FALSE)
set.seed(100)
```
### Daten einlesen
```{r}
# Einlesen der CSV-Dateien und erstellen der samples
movies <- read.csv("ml-latest-small/movies.csv", sep = ",")
links <- read.csv("ml-latest-small/links.csv", sep = ",")
ratings <- read.csv("ml-latest-small/ratings.csv", sep = ",")
tags <- read.csv("ml-latest-small/tags.csv", sep = ",")

# Sample von 70%
set.seed(69)
movies2 <- movies %>% slice_sample(prop = 0.7)
links2 <- subset(links, movieId %in% movies2$movieId)
ratings2 <- subset(ratings, movieId %in% movies2$movieId) %>% slice_sample(prop = 0.7)
tags2 <- subset(tags, movieId %in% movies2$movieId)

# 2ter Sample von 70%
set.seed(100)
movies <- movies %>% slice_sample(prop = 0.7)
links <- subset(links, movieId %in% movies$movieId)
ratings <- subset(ratings, movieId %in% movies$movieId) %>% slice_sample(prop = 0.7)
tags <- subset(tags, movieId %in% movies$movieId)
```
# Implementierung
## Programmierung der IBCF cos und IBCF jaccard
```{r}
calculate_jaccard <- function(arr1, arr2) {
  new_arr1 <- c()
  new_arr2 <- c()
  for (i in 2:length(arr1)) {
    if (!is.na(arr1[i]) & !is.na(arr2[i])) {
      new_arr1 <- append(new_arr1, arr1[i])
      new_arr2 <- append(new_arr2, arr2[i])
    }
  }
  new_arr1 <- unlist(new_arr1)
  new_arr2 <- unlist(new_arr2)
  jac_sim <- sum(new_arr1 == new_arr2) / length(new_arr1)
  return(jac_sim)
}
```

## Berechnung der Ähnlichkeitsmatrix
```{r}
calculate_cos <- function(arr1, arr2) {
  # Check which columns are available
  vals <- (!is.na(array(arr1)) & !is.na(array(arr2)))
  # Remove movieId column from cos similarity
  vals[1] <- FALSE
  # If there are common not na values, calculate cos sim
  if (sum(vals) != 0) {
    cos_sim <- cosine(arr1[vals], arr2[vals])
    return(cos_sim)
  }
  # If not, return NA
  return(NA)
}

getCorrelationMatrixCos <- function(data) { # Korrelation von Film zu Film berechen
  # Get array with movieId's
  movies <- as.character(data$movieId)
  
  # Create correlation matrix and set diag to 1
  correlations <- matrix(
    NA,
    nrow = length(movies),
    ncol = length(movies),
    dimnames = list(movies, movies)
  )
  diag(correlations) <- 1
  
  # Iterate through every movie and preload column
  i_counter = 0
  for (i in movies) {
    i_counter = i_counter + 1
    row_i <- data %>% filter(movieId == i)
    # For every movie, iterate through every movie
    j_counter = 0
    for (j in movies) {
      j_counter = j_counter + 1
      # If cos similarity was already calculated, skip, else continue
      if (i_counter <= j_counter) {
        # calculate cos sim
        row_j <- data %>% filter(movieId == j)
        sim <- calculate_cos(row_i, row_j)
        # set cos sim in sim matrix
        correlations[i,j] <- sim
        correlations[j,i] <- sim
      }
    }
    # Track progress
    print(paste(i_counter, " Datasets done"))
  }
  # Return correlation matrix
  return(correlations)
}
```

## Test der Funktionen
```{r}
# Erstellung der User-Rating Matrix
set.seed(100)
sample_values <- sample(1:6819, 300, replace = FALSE)

norm_ratings <- ratings %>%
  group_by(userId) %>%
  summarise(mean_rating = mean(rating), sd_rating = sd(rating)) %>%
  full_join(., ratings, by = "userId")

norm_ratings$z_rating <- (norm_ratings$rating - norm_ratings$mean_rating) /
  norm_ratings$sd_rating

item_user_random_100 <- norm_ratings %>%
  select(movieId, userId, z_rating) %>%
  pivot_wider(names_from = userId, values_from = z_rating) %>%
  filter(movieId %in% sample_values) %>%
  head(100)

getCorrelationMatrixCos(item_user_random_100)
```

```{r}
# Erstellung der User-Rating Like-Dislike Matrix
numToBool <- function(x) (x >= 0)
item_user_random_100_bool <- item_user_random_100 %>% mutate(across(!matches("movieId"), numToBool))

#predict_movie_rating_jaccard(item_user_random_100_bool, 1, 3386, 3)
```

## Vergleich mit recommenderlabs
```{r}
# item_user_random_100 <- as(item_user_random_100, "realRatingMatrix")
# IBCF1 <- Recommender(item_user_random_100, "IBCF",
#                        param=list(normalize = NULL, method="cosine"))
# p1 <- predict(IBCF1, item_user_random_100, type="topNList", n=30)
```

