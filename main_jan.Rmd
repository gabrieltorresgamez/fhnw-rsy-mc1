---
title: "RSY: MC1"
subtitle: "Studiengang Data Science (HS2022), FHNW"
author: "Jan Zwicky und Gabriel Torres"
date: "Letzte Aktualisierungen: `r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::html_document2:
      code_folding: show
      toc: true
      toc_depth: 2
      toc_float: true
      number_sections: true
editor_options: 
  chunk_output_type: console
---
<style>
#TOC {
  background-color: #F5F5F5;
  font-size: 16px;
}
#header{
  color: #708090;
  background-color: #F5F5F5;
  font-size: 30px;
}
body{
  color: #708090;
  background-color:#F5F5F5;
}
</style>

# Aufgabenstellung

# Daten aufbereiten und Pakete Lesen
## Pakete laden und Daten einlesen
### Pakete laden
```{r setup, cache = TRUE, message = FALSE, warning = FALSE}
# Pakete für Data Wrangling und Visualisierung
library(tidyverse)
library(rsample)
library(hablar)
library(gridExtra)

# Pakete für das HTML
library(bookdown)
library(knitr)

# Recommenderlab und ähnlich
library(recommenderlab)
library(vegan)
library(coop)
```
###  Konfiguration
```{r}
# Konfiguration der Pakete
knitr::opts_chunk$set(fit.align = "left", cache = TRUE, warning = FALSE, message = FALSE)
set.seed(100)
```
### Daten einlesen
```{r}
# Einlesen der CSV-Dateien und erstellen der samples
movies1 <- read.csv("ml-latest-small/movies.csv", sep = ",")
links1 <- read.csv("ml-latest-small/links.csv", sep = ",")
ratings1 <- read.csv("ml-latest-small/ratings.csv", sep = ",")
tags1 <- read.csv("ml-latest-small/tags.csv", sep = ",")

# Sample von 70%
set.seed(69)
movies2 <- movies1 %>% slice_sample(prop = 0.7)
links2 <- subset(links1, movieId %in% movies2$movieId)
ratings2 <- subset(ratings1, movieId %in% movies2$movieId) %>% slice_sample(prop = 0.7)
tags2 <- subset(tags1, movieId %in% movies2$movieId)

# 2ter Sample von 70%
set.seed(100)
movies1 <- movies1 %>% slice_sample(prop = 0.7)
links1 <- subset(links1, movieId %in% movies1$movieId)
ratings1 <- subset(ratings1, movieId %in% movies1$movieId) %>% slice_sample(prop = 0.7)
tags1 <- subset(tags1, movieId %in% movies1$movieId)
```

# EDA
## Welches sind die am häufigsten geschauten Filme?
### Sample 1
```{r}
left_join(movies1, ratings1, "movieId") %>%
  group_by(title, movieId, genres) %>%
  summarise(count = n()) %>%
  arrange(desc(count)) %>%
  head(3)
```

### Sample 2
```{r}
left_join(movies2, ratings2, "movieId") %>%
  group_by(title, movieId, genres) %>%
  summarise(count = n()) %>%
  arrange(desc(count)) %>%
  head(3)
```

### Beschreibung
In den beiden Outputs haben wir die Aufzählung der 3 meist bewerteten Filme, bei dem die Spalte 'count' die Anzahl Bewertungen ist.
Die Top 3 Filme wurden bei beiden Datensätzen etwa 180 bis 240 mal bewertet. Pulp Fiction und Star Wars kommen in beiden Datensätzen in unterschiedlicher Anzahl vor.

### Schlussfolgerung
Wir können nicht bestimmen, wie oft ein Film geschaut wurde, da es zu dieser Information keine Daten gibt. Als alternative definieren wir, dass geschaut und bewertet gleichgestellt wird.

## Welches sind die am häufigsten geschauten Genres?
### Sample 1
```{r}
genres_sep1 <- movies1 %>%
  separate_rows(genres, sep = "\\|", convert = FALSE) %>%
  replace(. == "", "no genres listed")

genres_sep1 %>%
  right_join(ratings1, "movieId") %>%
  group_by(genres) %>%
  summarise(count = n()) %>%
  arrange(desc(count)) %>%
  head(3)
```

### Sample 2
```{r}
genres_sep2 <- movies2 %>%
  separate_rows(genres, sep = "\\|", convert = FALSE) %>%
  replace(. == "", "no genres listed")

genres_sep2 %>%
  right_join(ratings2, "movieId") %>%
  group_by(genres) %>%
  summarise(count = n()) %>%
  arrange(desc(count)) %>%
  head(3)
```

**Beschreibung**
In beiden Outputs haben wir die meist bewerteten Filmgenres, bei dem die Spalte 'count' signalisiert, bei wie vielen Filmbewertungen der bewertete Film dieses Genre beinhaltet. Der Outputs ist bei beiden Datensätzen sehr ähnlich.

**Schlussfolgerung**
Die am meist geschauten/bewerteten Genres sind Drama, Comedy und Action.

## Wie verteilen sich die Kundenratings gesamthaft?
### Sample 1
```{r}
# Gesamthaft
summary(ratings1$rating)
ggplot(ratings1, aes(rating)) +
  geom_bar() +
  labs(
    title = "Verteilung der Kundenratings",
    x = "Bewertung",
    y = "Anzahl Bewertungen",
    subtitle = paste("Durchschnittsbewertung: ", mean(ratings1$rating))
  ) +
  theme_classic() +
  theme(legend.position = "none")
```

### Sample 2
```{r}
# Gesamthaft
summary(ratings2$rating)
ggplot(ratings2, aes(rating)) +
  geom_bar() +
  labs(
    title = "Verteilung der Kundenratings",
    x = "Bewertung",
    y = "Anzahl Bewertungen",
    subtitle = paste("Durchschnittsbewertung: ", mean(ratings2$rating))
  ) +
  theme_classic() +
  theme(legend.position = "none")
```

**Beschreibung**
In diesen Plots wird die Verteilung der Kundenratings visualisiert. 

**Schlussfolgerung**
Die Kundenratings sind nicht ganz normalverteilt, aber nahe. Die meisten Bewertungen sind im Bereich der natürlichen Zahlen, wenige Bewertungen sind ein Wert zwischen zwei dieser Zahlen. Öfters enthält eine Bewertung den Wert 4. Der Durchschnitt aller Bewertungen liegt bei etwa 3,5.

## Wie verteilen sich die Kundenratings nach Genres?
### Sample 1
```{r}
# Nach Genres
genres_sep_ratings1 <- genres_sep1 %>%
  right_join(ratings1, "movieId")
ggplot(genres_sep_ratings1, aes(x = rating, fill = genres)) +
  geom_bar(aes(y = ..prop.., group = 1)) +
  facet_wrap(~genres) +
  labs(
    title = "Verteilung der Kundenratings nach Genre",
    x = "Bewertung",
    y = "Verteilung",
  ) +
  theme_classic() +
  theme(legend.position = "none")
```

### Sample 2
```{r}
# Nach Genres
genres_sep_ratings2 <- genres_sep2 %>%
  right_join(ratings2, "movieId")
ggplot(genres_sep_ratings2, aes(x = rating, fill = genres)) +
  geom_bar(aes(y = ..prop.., group = 1)) +
  facet_wrap(~genres) +
  labs(
    title = "Verteilung der Kundenratings nach Genre",
    x = "Bewertung",
    y = "Verteilung",
  ) +
  theme_classic() +
  theme(legend.position = "none")
```

**Beschreibung**
Diese Plots sind ähnlich wie die letzten zwei. Hier wird die Verteilung der Kundenratings **nach Kategorie** visualisiert.

**Schlussfolgerung**
Die Verteilung der Kundenratings ähneln sich bei vielen Kategorien der Verteilung der Gesamtmenge. Jedoch mit einigen Ausnahmen: Dokumentarfilme haben zum Beispiel überdurchschnittlich viele Bewertungen mit dem Wert 4 und unterdurchschnittlich wenig Bewertungen mit dem Wert 3 und 5. Man könnte sagen, dass Dokumentarfilme sehr konstante Ratings haben.

## Wie verteilen sich die mittleren Kundenratings pro Film?
### Sample 1.1
```{r}
mean_rating_movie1 <- ratings1 %>%
  group_by(movieId) %>%
  summarise(mean_rating = mean(rating), count = n())

ggplot(mean_rating_movie1, aes(mean_rating)) +
  geom_histogram(bins = 50) +
  labs(
    title = "Verteilung der mittleren Kundenratings pro Film",
    x = "Durchschnittliche Bewertung",
    y = "Verteilung"
  ) +
  theme_classic()
```

### Sample 2.1
```{r}
mean_rating_movie2 <- ratings2 %>%
  group_by(movieId) %>%
  summarise(mean_rating = mean(rating), count = n())

ggplot(mean_rating_movie2, aes(mean_rating)) +
  geom_histogram(bins = 50) +
  labs(
    title = "Verteilung der mittleren Kundenratings pro Film",
    x = "Durchschnittliche Bewertung",
    y = "Verteilung"
  ) +
  theme_classic()
```

### Beschreibung 1
Hier wird die Verteilung der Durchschnittswerte der Bewertungen nach Film visualisiert.

### Schlussfolgerung 1
Da einige Filme nur wenige Bewertungen haben, liegen sehr viele Mittelwerte bei ganzen oder halben Zahlen. Deswegen gibt es bei unseren Plots einige hohe Balken.

### Sample 1.2
```{r}
ggplot(mean_rating_movie1 %>% filter(count >= 5), aes(mean_rating)) +
  geom_histogram(bins = 50) +
  labs(
    title = "Verteilung der mittleren Kundenratings pro Film",
    x = "Durchschnittliche Bewertung",
    y = "Verteilung"
  ) +
  theme_classic()
```

### Sample 2.2
```{r}
ggplot(mean_rating_movie2 %>% filter(count >= 5), aes(mean_rating)) +
  geom_histogram(bins = 50) +
  labs(
    title = "Verteilung der mittleren Kundenratings pro Film",
    x = "Durchschnittliche Bewertung",
    y = "Verteilung"
  ) +
  theme_classic()
```

**Beschreibung 2**
Hier wird das gleiche wie beim letzten Plot visualisiert. Jedoch wurden Filme mit weniger als 5 Bewertungen entfernt.

**Schlussfolgerung 2**
Wenn man alle Filme mit weniger als 5 Bewertungen entfernt, erkennt man, dass die Bewertungen der Filme linksschief verteilt sind.

### Sample 1.3
```{r}
ggplot(mean_rating_movie1, aes(mean_rating, count, color = mean_rating)) +
  geom_point(alpha = 0.3) +
  labs(
    title = "Verteilung der mittleren Kundenratings pro Film",
    x = "Durchschnittliche Bewertung",
    y = "Anzahl Bewertungen"
  ) +
  theme_classic() +
  scale_color_gradient(low = "red", high = "green") +
  theme(legend.position = "none")
```

### Sample 2.3
```{r}
ggplot(mean_rating_movie2, aes(mean_rating, count, color = mean_rating)) +
  geom_point(alpha = 0.3) +
  labs(
    title = "Verteilung der mittleren Kundenratings pro Film",
    x = "Durchschnittliche Bewertung",
    y = "Anzahl Bewertungen"
  ) +
  theme_classic() +
  scale_color_gradient(low = "red", high = "green") +
  theme(legend.position = "none")
```

**Beschreibung 3**
Hier wird die Verteilung der Durchschnittswerte der Bewertungen nach Film in Abhängigkeit von der Anzahl Bewertungen nach Film visualisiert.

**Schlussfolgerung 3**
Hier werden die gleichen Daten anders dargestellt. Man erkennt, dass desto öfters ein Film bewertet wird, desto näher liegt die durchschnittliche Bewertung bei 4. Man kann dies vielleicht begründen, indem man sagt, dass ein schlechter Film weniger geschaut und deswegen weniger bewertet wird. Jedoch können wir uns nur schwer erklären, wieso Filme mit einer Bewertung über 4 nicht so oft geschaut/bewertet werden. 

## Wie stark streuen die Ratings von individuellen Kunden?
### Sample 1.1
```{r}
sample_values <- sample(1:610, 4, replace = FALSE)

ratings1 %>%
  filter(userId %in% sample_values) %>%
  ggplot(., aes(rating)) +
  geom_density(aes(color = factor(userId))) +
  labs(
    title = "Streuung von Bewertungen von Kunden",
    subtitle = "random sample",
    x = "Bewertung",
    y = "Verteilung",
    color = "User ID"
  ) +
  theme_classic()
```

### Sample 2.1
```{r}
sample_values <- sample(1:610, 4, replace = FALSE)

ratings2 %>%
  filter(userId %in% sample_values) %>%
  ggplot(., aes(rating)) +
  geom_density(aes(color = factor(userId))) +
  labs(
    title = "Streuung von Bewertungen von Kunden",
    subtitle = "random sample",
    x = "Bewertung",
    y = "Verteilung",
    color = "User ID"
  ) +
  theme_classic()
```

### Sample 1.2
```{r}
sd_ratings1 <- ratings1 %>%
  group_by(userId) %>%
  summarise(SD = sd(rating), count = n())

ggplot(sd_ratings1, aes(SD, count, color = count)) +
  geom_point() +
  labs(
    title = "Standardabweichung der Ratings pro User",
    x = "Standardabweichung",
    y = "Anzahl Ratings",
    color = "Anzahl Ratings"
  ) +
  theme_classic() +
  scale_color_gradient(low = "green", high = "black") +
  theme(legend.position = "none")
```
```{r}
ggplot(sd_ratings1, aes(SD)) +
  geom_boxplot() +
  labs(
    title = "Standardabweichung der Ratings pro User",
    x = "Standardabweichung",
    subtitle = paste("Durchschnittsstandardabweichung: ", mean(sd_ratings1$SD)),
  ) +
  theme_classic()
```

### Sample 2.2
```{r}
sd_ratings2 <- ratings2 %>%
  group_by(userId) %>%
  summarise(SD = sd(rating), count = n())

ggplot(sd_ratings2, aes(SD, count, color = count)) +
  geom_point() +
  labs(
    title = "Standardabweichung der Ratings pro User",
    x = "Standardabweichung",
    y = "Anzahl Ratings",
    color = "Anzahl Ratings"
  ) +
  theme_classic() +
  scale_color_gradient(low = "green", high = "black") +
  theme(legend.position = "none")
```
```{r}
ggplot(sd_ratings2, aes(SD)) +
  geom_boxplot() +
  labs(
    title = "Standardabweichung der Ratings pro User",
    x = "Standardabweichung",
    subtitle = paste("Durchschnittsstandardabweichung: ", mean(sd_ratings1$SD)),
  ) +
  theme_classic()
```

**Beschreibung**
In allen Plots werden die Standardabweichungen aller Bewertungen individueller User geplottet. In den Scatterplots wird zusätzlich die Anzahl Ratings an der y-Achse visualisiert.

**Schlussfolgerung**
Der Mittelwert der Standardabweichung der Ratings der User befindet sich um den Wert 0,9. Die Bewertungen streuen sich weniger als bei einer Normalverteilung.

## Welchen Einfluss hat die Normierung der Ratings pro Kunde auf deren Verteilung?
### Sample 1
```{r}
norm_ratings1 <- ratings1 %>%
  group_by(userId) %>%
  summarise(mean_rating = mean(rating), sd_rating = sd(rating)) %>%
  full_join(., ratings1, by = "userId")

norm_ratings1$z_rating <- (norm_ratings1$rating - norm_ratings1$mean_rating) /
  norm_ratings1$sd_rating

ggplot(norm_ratings1, aes(z_rating)) +
  geom_density() +
  labs(
    title = "Normierte Ratings",
    x = "Z-Normiertes Rating",
    y = "Verteilung"
  ) +
  theme_classic()
```

```{r}
sample_values1 <- sample(1:610, 4, replace = FALSE)

norm_ratings1 %>%
  filter(userId %in% sample_values) %>%
  ggplot(., aes(z_rating)) +
  geom_density(aes(color = factor(userId))) +
  labs(
    title = "Normierte Ratings von Kunden",
    subtitle = "random sample",
    x = "Normierte Bewertung",
    y = "Verteilung",
    color = "User ID"
  ) +
  theme_classic()
```

### Sample 2
```{r}
norm_ratings2 <- ratings2 %>%
  group_by(userId) %>%
  summarise(mean_rating = mean(rating), sd_rating = sd(rating)) %>%
  full_join(., ratings2, by = "userId")

norm_ratings2$z_rating <- (norm_ratings2$rating - norm_ratings2$mean_rating) /
  norm_ratings2$sd_rating

ggplot(norm_ratings2, aes(z_rating)) +
  geom_density() +
  labs(
    title = "Normierte Ratings",
    x = "Z-Normiertes Rating",
    y = "Verteilung"
  ) +
  theme_classic()
```

```{r}
sample_values2 <- sample(1:610, 4, replace = FALSE)

norm_ratings2 %>%
  filter(userId %in% sample_values) %>%
  ggplot(., aes(z_rating)) +
  geom_density(aes(color = factor(userId))) +
  labs(
    title = "Normierte Ratings von Kunden",
    subtitle = "random sample",
    x = "Normierte Bewertung",
    y = "Verteilung",
    color = "User ID"
  ) +
  theme_classic()
```

**Beschreibung**
In diesen Plots visualisieren wir zuerst die normierte Verteilung der Ratings von 4 zufällig gewählten User und danach visualisieren wir die normierte Verteilung der Ratings der Gesamtmenge.

**Schlussfolgerung**
Der Mittelwert der Bewertungen pro User befindet sich jetzt bei 0. Alle Ratings unter 0 könnte man als "gefällt dem User nicht" interpretieren und alle Rating über 0 könnte man als "gefällt dem User" interpretieren. Desto weiter sich die Bewertung von 0 entfernt desto mehr oder weniger gefällt dem User der Film.

## Welche strukturellen Charakteristika (z.B.Sparsity) und Auffälligkeiten zeigt die User-Item Matrix?
### Sample 1
```{r}
user_item1 <- norm_ratings1 %>%
  select(movieId, userId, z_rating) %>%
  pivot_wider(names_from = movieId, values_from = z_rating)

sum(is.na(user_item1)) / (dim(user_item1)[1] * (dim(user_item1)[2]))
```

### Sample 2
```{r}
user_item2 <- norm_ratings2 %>%
  select(movieId, userId, z_rating) %>%
  pivot_wider(names_from = movieId, values_from = z_rating)

sum(is.na(user_item2)) / (dim(user_item2)[1] * (dim(user_item2)[2]))
```

**Beschreibung**
Division der NA Werte durch die Anzahl Werte (NA & nicht NA).

**Schlussfolgerung**
Die User-Item Matrizen sind zu 98.6 % Sparse.

# Datenreduktion
Die Daten wurden auf 400 Kunden und 700 Filme reduziert, indem Filme und Kunden mit sehr wenigen Ratings entfernt wurden

## Reduktion
### Sample 1
```{r}
# Filter 700 most rated movies
top_n_movies1 <- norm_ratings1 %>%
  group_by(movieId) %>%
  count() %>%
  arrange(desc(n)) %>%
  head(700)

# Join data on 700 most rated movies
user_item_r1 <-
  left_join(
    top_n_movies1,
    norm_ratings1,
    by = "movieId"
  )

# Filter 700 most rated user
top_n_user1 <- user_item_r1 %>%
  group_by(userId) %>%
  count() %>%
  arrange(desc(n)) %>%
  head(400) %>%
  ungroup()

# Join data on 400 most rated user (only 700 movies)
user_item_r1 <-
  left_join(
    top_n_user1,
    user_item_r1,
    by = "userId"
  ) %>%
  select(userId, movieId, z_rating)

# Pivot wider
m_user_item_r1 <- user_item_r1 %>%
  pivot_wider(names_from = movieId, values_from = z_rating) %>%
  column_to_rownames(., var = "userId")
```



### Sample 2
```{r}
# Filter 700 most rated movies
top_n_movies2 <- norm_ratings2 %>%
  group_by(movieId) %>%
  count() %>%
  arrange(desc(n)) %>%
  head(700)

# Join data on 700 most rated movies
user_item_r2 <-
  left_join(
    top_n_movies2,
    norm_ratings2,
    by = "movieId"
  )

# Filter 700 most rated user
top_n_user2 <- user_item_r2 %>%
  group_by(userId) %>%
  count() %>%
  arrange(desc(n)) %>%
  head(400) %>%
  ungroup()

# Join data on 400 most rated user (only 700 movies)
user_item_r2 <-
  left_join(
    top_n_user2,
    user_item_r2,
    by = "userId"
  ) %>%
  select(userId, movieId, z_rating)

# Pivot wider
m_user_item_r2 <- user_item_r2 %>%
  pivot_wider(names_from = movieId, values_from = z_rating) %>%
  column_to_rownames(., var = "userId")
```

## Sparsity nach Datenreduktion
### Sample 1
```{r}
# Sparsity Sample 1
sum(is.na(m_user_item_r1)) / (dim(m_user_item_r1)[1] * (dim(m_user_item_r1)[2]))
```

### Sample 2
```{r}
# Sparsity Sample 2
sum(is.na(m_user_item_r2)) / (dim(m_user_item_r2)[1] * (dim(m_user_item_r2)[2]))
```

**Beschreibung**
Hier wurden die Sparsities der neuen Matrizen berechnet.

**Schlussfolgerung**
Die Sparsity wurde deutlich reduziert. Anstatt 98.6% beträgt sie jetzt nur 90%

## Mittlere Kundenratings pro Film vor und nach Datenreduktion
### Sample 1
```{r}
moviemeans_reducted1 <- colMeans(m_user_item_r1, na.rm = TRUE)
moviemeans_reducted1 <- data.frame(moviemeans_reducted1)
ggplot(moviemeans_reducted1, aes(moviemeans_reducted1)) +
  geom_density() +
  labs(
    title = "Streuung von durchschnittlichen Bewertung von Filmen",
    subtitle = "reduzierter Datensatz 1",
    x = "durchschnittliche Bewertung",
    y = "Verteilung"
  ) +
  theme_classic() +
  xlim(-2, 2)
```

```{r}
moviemeans1 <- colMeans(user_item1 %>% column_to_rownames(., var = "userId"), na.rm = TRUE)
moviemeans1 <- data.frame(moviemeans1)
ggplot(moviemeans1, aes(moviemeans1)) +
  geom_density() +
  labs(
    title = "Streuung von durchschnittlichen Bewertung von Filmen",
    subtitle = "kompletter Datensatz 1",
    x = "durchschnittliche Bewertung",
    y = "Verteilung"
  ) +
  theme_classic() +
  xlim(-2, 2)
```

### Sample 2
```{r}
moviemeans_reducted2 <- colMeans(m_user_item_r2, na.rm = TRUE)
moviemeans_reducted2 <- data.frame(moviemeans_reducted2)
ggplot(moviemeans_reducted2, aes(moviemeans_reducted2)) +
  geom_density() +
  labs(
    title = "Streuung von durchschnittlichen Bewertung von Filmen",
    subtitle = "reduzierter Datensatz 2",
    x = "durchschnittliche Bewertung",
    y = "Verteilung"
  ) +
  theme_classic() +
  xlim(-2, 2)
```

```{r}
moviemeans2 <- colMeans(user_item2 %>% column_to_rownames(., var = "userId"), na.rm = TRUE)
moviemeans2 <- data.frame(moviemeans2)
ggplot(moviemeans2, aes(moviemeans2)) +
  geom_density() +
  labs(
    title = "Streuung von durchschnittlichen Bewertung von Filmen",
    subtitle = "kompletter Datensatz 2",
    x = "durchschnittliche Bewertung",
    y = "Verteilung"
  ) +
  theme_classic() +
  xlim(-2, 2)
```

**Beschreibung**
Hier wird die Streuung der durchschnittlichen Bewertung einzelner Filme visualisiert. Es wird dabei der reduzierte Datensatz mit dem kompletten Datensatz verglichen.

**Schlussfolgerung**
Man erkennt, dass die Daten beim reduzierten Datensatz grösstenteils nur im Bereich [-1, 1] streuen. Dies ist auch realistisch da es wahrscheinlicher ist, dass ein Film welches nur 1 Mal bewertet wurde eine Bewertung von z.B. -2 hat, als dass 10 User den gleichen Film so schlecht bewerten, dass der Durchschnitt bei -2 liegt.

## Quantifiziere “Intersection over Union” der Ratings der unterschiedlich reduzierten Datensätze.
```{r}
intersection <- nrow(inner_join(user_item_r1, user_item_r2, by = c("movieId", "userId")))
union <- nrow(user_item_r1) + nrow(user_item_r2) - intersection
intersection / union
```

**Beschreibung**
Die berechnete Zahl bezeichnet das Verhältnis von Bewertungen, welche in beiden Datensätzen vorhanden ist.

**Schlussfolgerung**
Die Schnittmenge der Bewertungen zwischen beiden Datensätzen beträgt etwa 30% der Gesamtmenge.

# Analyse Ähnlichkeitsmatrix
## Zerlege den reduzierten MovieLense Datensatz in ein disjunktes Trainings- und Testdatenset im Verhältnis 4:1
### Sample 1
```{r}
set.seed(69)
split1 <- initial_split(m_user_item_r1, prop = 0.80)
training1 <- as.matrix(training(split1))
test1 <- as.matrix(testing(split1))
```

### Sample 2
```{r}
set.seed(100)
split2 <- initial_split(m_user_item_r2, prop = 0.80)
training2 <- as.matrix(training(split2))
test2 <- as.matrix(testing(split2))
```

## Trainiere ein IBCF Modell mit 30 Nachbarn und Cosine Similarity
### Sample 1
```{r}
IBCF1 <- Recommender(as(training1, "realRatingMatrix"), "IBCF",
  param = list(normalize = NULL, method = "cosine", k = 30, na_as_zero = TRUE)
)
```

### Sample 2
```{r}
IBCF2 <- Recommender(as(training2, "realRatingMatrix"), "IBCF",
  param = list(normalize = NULL, method = "cosine", k = 30,na_as_zero = TRUE)
)
```

## Bestimme die Verteilung der Filme, welche bei IBCF für paarweise Ähnlichkeitsvergleiche verwendet werden
### Sample 1
```{r}
# extract IBCF similarity matrix
IBCF_sim_matrix1 <- as.data.frame(as.matrix(IBCF1@model[["sim"]]))

# count number of occurrences
IBCF_freq1 <- as.data.frame(colSums(IBCF_sim_matrix1 != 0), optional = TRUE)
colnames(IBCF_freq1) <- "frequency"
ggplot(IBCF_freq1, aes(frequency)) +
  geom_histogram(bins = 30) +
  labs(
    title = "Verteilung des Vorkommens der Filme in den Top 30 Ähnlichkeitslisten",
    x = "Anzahl Vorkommen des Filmes in der Ähnlichkeitsmatrix",
    y = "Anzahl Filme mit gleichem Vorkommen"
  ) +
  theme_classic()
```

### Sample 2
```{r}
# extract IBCF similarity matrix
IBCF_sim_matrix2 <- as.data.frame(as.matrix(IBCF2@model[["sim"]]))

# count number of occurrences
IBCF_freq2 <- as.data.frame(colSums(IBCF_sim_matrix2 != 0), optional = TRUE)
colnames(IBCF_freq2) <- "frequency"
ggplot(IBCF_freq2, aes(frequency)) +
  geom_histogram(bins = 30) +
  labs(
    title = "Verteilung des Vorkommens der Filme in den Top 30 Ähnlichkeitslisten",
    x = "Anzahl Vorkommen des Filmes in der Ähnlichkeitsmatrix",
    y = "Anzahl Filme mit gleichem Vorkommen"
  ) +
  theme_classic()
```

**Beschreibung**
Hier wird visualisiert, wie viele Filme wie oft in der Top 30 Ähnlichkeitsliste jedes einzelnes Filmes auftreten. Die y-Achse beschreibt, wieviel Filme in X Top 30 Ähnlichkeitslisten vorkommt und die x-Achse beschreibt, in wievielen Top 30 Ähnlichkeitsliste ein bestimmter Film vorkommt.

**Schlussfolgerung**
Hier sieht die Verteilung bei beiden Datensätzen anders aus. Beim ersten Datensatz sieht die Verteilung eher Normalverteilt aus. Beim zweiten Datensatz sieht sie Verteilung eher Exponentialverteilt aus.

## Bestimme die Filme, die am häufigsten in der Cosine-Ähnlichkeitsmatrix auftauchen und analysiere deren Vorkommen und Ratings im reduzierten Datensatz.
### Häufigkeit der Filme
#### Sample 1
```{r}
# Add movieId as column
IBCF_freq1$movieId <- rownames(IBCF_freq1)

# sort by frequency, select most frequent movies
IBCF_freq_head1 <- IBCF_freq1 %>%
  arrange(desc(frequency)) %>%
  head(30) %>%
  convert(int(movieId))

# count occurrency and the mean rating of the reduced data
IBCF_freq_head1 <- left_join(IBCF_freq_head1, norm_ratings1, by = "movieId") %>%
  group_by(movieId) %>%
  summarise(
    count = n(),
    mean = mean(z_rating)
  )

ggplot(IBCF_freq_head1, aes(count)) +
  geom_histogram(binwidth = 5) +
  labs(
    title = "Anzahl Ratings der 30 meist vorgeschlagenen Filme",
    x = "Anzahl Ratings",
    y = "Anzahl Filme"
  ) +
  xlim(0, NA) +
  theme_classic()
```

#### Sample 2
```{r}
# Add movieId as column
IBCF_freq2$movieId <- rownames(IBCF_freq2)

# sort by frequency, select most frequent movies
IBCF_freq_head2 <- IBCF_freq2 %>%
  arrange(desc(frequency)) %>%
  head(30) %>%
  convert(int(movieId))

# count occurrency and the mean rating of the reduced data
IBCF_freq_head2 <- left_join(IBCF_freq_head2, norm_ratings2, by = "movieId") %>%
  group_by(movieId) %>%
  summarise(
    count = n(),
    mean = mean(z_rating)
  )

ggplot(IBCF_freq_head2, aes(count)) +
  geom_histogram(binwidth = 1) +
  labs(
    title = "Anzahl Ratings der 30 meist vorgeschlagenen Filme",
    x = "Anzahl Ratings",
    y = "Anzahl Filme"
  ) +
  xlim(0, NA) +
  theme_classic()
```

**Beschreibung**
Aus den Top 30 ähnlichen Filmen aller Filme, werden die Top 30 Filme mit den meisten Vorkommen ausgewählt und danach die Anzahl Ratings dieser Filme visualisiert.

**Schlussfolgerung**
Die am meist vorgeschlagenen Filme haben in beiden reduzierten Datensätze um die 20 oder mehr Ratings. Beim ersten Datensatz haben die meisten Filme meistens zwischen 20 und 50 Ratings. Beim zweiten Datensatz haben die meisten Filme meistens um die 20 bis 30 Ratings.

### Durchschnittliche Ratings der Filme
#### Sample 1
```{r}
ggplot(IBCF_freq_head1, aes(mean)) +
  geom_density() +
  geom_vline(xintercept = 0, alpha = 0.5, color = "magenta") +
  labs(
    title = "Verteilung der normierten Bewertungen der 30 meist vorgeschlagenen Filme",
    subtitle = paste("Mittelwert: ", mean(IBCF_freq_head1$mean)),
    x = "Normierte Bewertung",
    y = "Verteilung"
  ) +
  theme_classic()
```

#### Sample 2
```{r}
ggplot(IBCF_freq_head2, aes(mean)) +
  geom_density() +
  geom_vline(xintercept = 0, alpha = 0.5, color = "magenta") +
  labs(
    title = "Verteilung der normierten Bewertungen der 30 meist vorgeschlagenen Filme",
    subtitle = paste("Mittelwert: ", mean(IBCF_freq_head2$mean)),
    x = "Normierte Bewertung",
    y = "Verteilung"
  ) +
  theme_classic()
```

**Beschreibung**
Hier wird die Verteilung der normierten Bewertungen der 30 meist vorgeschlagenen Filme visualisiert. Weiterhin haben wir eine vertikale Linie implementiert, welche die Boundary zwischen einer guten (rechts) und einer schlechten (links) Bewertung bildet.

**Schlussfolgerung**
Die 30 am meist vorgeschlagenen Filme tendieren dazu, überdurchschnittlich gut bewertete Filme zu sein. Das können wir daraus formulieren, das der Mittelwert der Bewertungen beider Datensätze über den Wert 0 liegen. Beim ersten Datensatz ist dies klarer zu erkennen, als beim zweiten.


# Analyse Top-N Listen - IBCF vs UBCF
## Berechne Top-15 Empfehlungen für Testkunden mit IBCF und UBCF
### Sample 1
```{r}
# predict IBCF
pIBCF1 <- predict(IBCF1, as(test1, "realRatingMatrix"), type = "topNList", n = 15)
```

```{r}
# calc frequency of predicted movies
freq_pred_IBCF1 <- table(unlist(as(pIBCF1, "list"))) %>%
  as.data.frame() %>%
  rename(movieId = Var1) %>%
  arrange(desc(Freq))
```

```{r}
# train UBCF
UBCF1 <- Recommender(as(training1, "realRatingMatrix"), "UBCF",
  param = list(normalize = NULL, method = "cosine", nn = 30)
)

# predict UBCF
pUBCF1 <- predict(UBCF1, as(test1, "realRatingMatrix"), type = "topNList", n = 15)
```

```{r}
# calc frequency of predicted movies
freq_pred_UBCF1 <- table(unlist(as(pUBCF1, "list"))) %>%
  as.data.frame() %>%
  rename(movieId = Var1) %>%
  arrange(desc(Freq))
```

### Sample 2
```{r}
# predict IBCF
pIBCF2 <- predict(IBCF2, as(test2, "realRatingMatrix"), type = "topNList", n = 15)
```

```{r}
# calc frequency of predicted movies
freq_pred_IBCF2 <- table(unlist(as(pIBCF2, "list"))) %>%
  as.data.frame() %>%
  rename(movieId = Var1) %>%
  arrange(desc(Freq))
```

```{r}
# train UBCF
UBCF2 <- Recommender(as(training2, "realRatingMatrix"), "UBCF",
  param = list(method = "cosine", nn = 30)
)

# predict UBCF
pUBCF2 <- predict(UBCF2, as(test2, "realRatingMatrix"), type = "topNList", n = 15)
```

```{r}
# calc frequency of predicted movies
freq_pred_UBCF2 <- table(unlist(as(pUBCF2, "list"))) %>%
  as.data.frame() %>%
  rename(movieId = Var1) %>%
  arrange(desc(Freq))
```

## Vergleiche die Top-15 Empfehlungen und deren Verteilung und diskutiere Gemeinsamkeiten und Unterschiede zwischen IBCF und UBCF für alle Testkunden.
**Hypothese:** Recommender Systeme machen für alle Nutzer die gleichen Empfehlungen.

### Sample 1
```{r}
freq_pred_UBCF1$type <- "UBCF"
freq_pred_IBCF1$type <- "IBCF"

moviesUIBCF1 <- rbind(freq_pred_UBCF1, freq_pred_IBCF1)
```

```{r}
ggplot(moviesUIBCF1, aes(Freq, fill = type)) +
  geom_histogram(alpha = 0.6, position = "dodge", binwidth = 0.5) +
  scale_fill_manual(values = c("#69b3a2", "#404080")) + 
  labs(
    title = "Häufigkeit der Empfehlung von Filmen",
    x = "Anzahl Empfehlungen pro Film",
    y = "Anzahl Filme",
    fill = "Modell"
  ) +
  theme_classic()
```

### Sample 2
```{r}
freq_pred_UBCF2$type <- "UBCF"
freq_pred_IBCF2$type <- "IBCF"

moviesUIBCF2 <- rbind(freq_pred_UBCF2, freq_pred_IBCF2)
```

```{r}
ggplot(moviesUIBCF2, aes(Freq, fill = type)) +
  geom_histogram(alpha = 0.6, position = "dodge", binwidth = 0.5) +
  scale_fill_manual(values = c("#69b3a2", "#404080")) + 
  labs(
    title = "Häufigkeit der Empfehlung von Filmen",
    x = "Anzahl Empfehlungen pro Film",
    y = "Anzahl Filme",
    fill = "Modell"
  ) +
  theme_classic()
```

**Beschreibung**
Hier wird visualisiert, wie oft Filme bei IBCF und UBCF empfohlen werden. Auf der x-Achse befindet sich die Anzahl Empfehlungen pro Film und auf der y-Achse wieviele oft die anzahl Empfehlungen pro Film gleich sind.
Der ICBF Recommender empfiehlt, dabei merh unterschiedliche Filme als der UBCF recommender. Der UCBF Recommender empfiehlt bis zu 24 mal den gleichen Film. 

**Schlussfolgerung**
Die Hypothese wurde wiederlegt, da diverse Filme nur einmal vorgeschlagen werden. Zudem werden keine Filme mehr als 24 mal vorgeschlagen.

# Analyse Top-N Listen - Ratings
Funktion um die Überschneidungen zu berechnen.
```{r}
intersection_Top15 <- function(prediction1, prediction2,Model1, Model2,Datensatz,return_plot = FALSE) {
   predTopN1 <- as.data.frame(as(prediction1, "matrix"))
  predTopN1$user <- rownames(predTopN1)
  predTopN1 <- pivot_longer(predTopN1, cols = -c(user), values_drop_na = TRUE)
  
  predTopN2 <- as.data.frame(as(prediction2, "matrix"))
predTopN2$user <- rownames(predTopN2)
predTopN2 <- pivot_longer(predTopN2, cols = -c(user), values_drop_na = TRUE)


intersect <- left_join(predTopN1, predTopN2, by = c("user", "name"))

# count intersect
plot <- intersect %>%
  select(user, value.y) %>%
  group_by(user) %>%
  summarise(total_intersect = sum(!is.na(value.y))) %>%
  ggplot(aes(total_intersect)) +
  geom_histogram(binwidth = 0.5)+
  labs(
    title = "Überschneidungen von Top-15 listen",
    x = "Anzahl Überschneidungen der Bewertungen",
    y = "Anzahl User",
    subtitle = paste(Model1,"und",Model2),
    caption =  paste("Datensatz",Datensatz)) +
  scale_x_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1))))) + # integer on x_axis
  theme_classic() +
  theme(legend.position = "none")
if (return_plot) {
return(plot)
} else {
print(plot)
}
}
```

## IBCF vs UBCF, beide mit ordinalem Rating und Cosine Similarity für alle Testkunden
**Hypothese:** Basierend auf der vorherigen Aufgabe, gehen wir davon aus, dass die Anzahl übereinstimmenden Filme relativ klein ist. Da die Verteilungen bei der Aufgabe 5 unterschiedlich sind.

```{r}
intersection_Top15(pUBCF1,pIBCF1,"UBCF Cosine","IBCF Cosine","1")
```

```{r}
intersection_Top15(pUBCF2,pIBCF2,"UBCF Cosine","IBCF Cosine","2")
```
**Beobachtung:** Die Überschneidung der Daten ist niedrig. Die Meisten Kunden haben keine Überschneidung.

**Schlussfolgerung:** Da der Algorithmus unterschiedlich ist und es diverse mögliche Filme zur Auswahl hat, sind die Top-N listen unterschiedlich.


## IBCF vs UBCF, beide mit binärem Rating und Jaccard Similarity für alle Testkunden
**Hypothese:** Die Überschneidung ist grösser wie bei der Cosine Similarity. Trotzdem werden den meisten User unterschiedliche Filme vorgeschlagen.
```{r}
# Sample 1
# Create binary training and test data
training_binary1 <- training1 > 0
training_binary1[is.na(training_binary1)] <- 0

test_binary1 <- test1 > 0
test_binary1[is.na(test_binary1)] <- 0
```

```{r}
# Sample 2
# Create binary training and test data
training_binary2 <- training2 > 0
training_binary2[is.na(training_binary2)] <- 0

test_binary2 <- test2 > 0
test_binary2[is.na(test_binary2)] <- 0
```

```{r}
# sample 1
# Train and test binary UBCF-recommender
UBCF_binary1 <- Recommender(as(training_binary1, "realRatingMatrix"), "UBCF", param = list(normalize = NULL, method = "jaccard"))
pUBCF_binary1 <- predict(UBCF_binary1, as(test1, "realRatingMatrix"), type = "topNList", n = 15)

# Train and test binary IBCF-recommender
IBCF_binary1 <- Recommender(as(training_binary1, "realRatingMatrix"), "IBCF", param = list(normalize = NULL, method = "jaccard"))
pIBCF_binary1 <- predict(IBCF_binary1, as(test1, "realRatingMatrix"), type = "topNList", n = 15)
#calculate and plot intersection
intersection_Top15(pUBCF_binary1,pIBCF_binary1,"UBCF binary","IBCF binary","1")
```

```{r}
# sample 2
# Train and test binary UBCF-recommender
UBCF_binary2 <- Recommender(as(training_binary2, "realRatingMatrix"), "UBCF", param = list(normalize = NULL, method = "jaccard"))
pUBCF_binary2 <- predict(UBCF_binary2, as(test2, "realRatingMatrix"), type = "topNList", n = 15)

# Train and test binary IBCF-recommender
IBCF_binary2 <- Recommender(as(training_binary2, "realRatingMatrix"), "UBCF", param = list(normalize = NULL, method = "jaccard"))
pIBCF_binary2 <- predict(IBCF_binary1, as(test2, "realRatingMatrix"), type = "topNList", n = 15)

#calculate and plot intersection
intersection_Top15(pUBCF_binary2,pIBCF_binary2,"UBCF binary","IBCF binary","2")
```
**Beobachtung:** Bei den meisten Usern gibt es keine Überschneidung, bei den unterschiedlichen Recommender. Bei diesen Algorithm gibt es User mit 6 Überschneidungen.

**Schlussfolgerung** Die Hypothese wurde bestätigt. Die Überschneidungen sind grösser wie bei den Recommender mit Kosinus Ähnlichkeiten. Trotzdem hat es im Datensatz 2 fast 60 User die keine Überschneidungen hat.


## UBCF mit ordinalem (Cosine Similarity) vs UBCF mit binärem Rating (Jaccard Similarity) für alle Testkunden.
**Hypothese:** Die beiden Recommender sind unterschiedlicher wie die bis anhin untersuchten. Somit sollten sie deutlich weniger Überschneidungen aufweisen.

```{r}
intersection_Top15(pUBCF1,pUBCF_binary1,"UBCF binary","UBCF cosine","1")
```

```{r}
intersection_Top15(pUBCF2,pUBCF_binary2,"UBCF binary","UBCF cosine","2")
```
**Beobachtungen:** Es hat fast keine Überschneidungen. Im zweiten Datensatz hat ein User 5 Filme in beiden Top-N Listen.

**Schlussfolgerung:** Die Hypothese kann angenommen werden. Es hat aber nur leicht weniger Überschneidungen, wie beim Vergleich mit ordinalen Ratings und Kosinus Ähnlichkeiten.

## IBCF (Na_as_zeros = FALSE) vs IBCF (Na_as_zeros = TRUE)

Zusätzlich zu den Aufgaben wird noch überprüft ob es ein Unterschied macht wenn die NA gelöscht werden. (Anstatt mit 0 überschrieben)

**Hypothese:** Die Überschneidungen sollten gross sein.  

```{r}
IBCF1_na_false <- Recommender(as(training2, "realRatingMatrix"), "IBCF",
  param = list(normalize = NULL, method = "cosine", k = 30,na_as_zero = FALSE)
)
pIBCF1_na_false<- predict(IBCF1_na_false, as(test1, "realRatingMatrix"), type = "topNList", n = 15)

intersection_Top15(pIBCF1_na_false,pIBCF1,"UBCF cosine mit na","UBCF cosine ohne na","1")
```

```{r}
IBCF2_na_false <- Recommender(as(training2, "realRatingMatrix"), "IBCF",
  param = list(normalize = NULL, method = "cosine", k = 30,na_as_zero = FALSE)
)
pIBCF2_na_false<- predict(IBCF2_na_false, as(test2, "realRatingMatrix"), type = "topNList", n = 15)
intersection_Top15(pIBCF2_na_false,pIBCF2,"UBCF cosine mit na","UBCF cosine ohne na","2")
```

**Beobachtung:** Im ersten Datensatz sind die Überschneidungen klein. Die meisten User haben 0 Überschneidungen. Im zweiten Datensatz hat es deutlich mehr Überschneidungen.

**Schlussfolgerung:** Die Hypothese wird abgelehnt. Es hat einen Einfluss, ob die NA-Werte auf 0 gesetzt werden oder gelöscht werden. Wenn die NA auf 0 gesetzt werden wird die Ähnlichkeit tendenziell kleiner. Da bei der Kosinus Ähnlichkeit der Nenner grösser wird und der Zähler nicht. Es macht Sinn das die Ähnlichkeit kleiner ist, wenn es wenig übereinstimmende Ratings hat.

## Allgemeine Schlussfolgerung

Bei dieser Aufgabe wurde erkannt, dass das Resultat je nach Einstellungen des Recommender, sehr unterschiedlich sein kann. Um herauszufinden welcher Recommender gut ist, müssen diese Evaluiert werden. Dies wird in den Aufgabe 9 und 10 genauer untersucht.


# Analyse Top-N Listen - IBCF vs SVD
In diesem Abschnitt wird ein IBCF Recommender mit einem SVD Recommender verglichen. Der SVD Recommender wird mit 10,20,30,40 und 50 Singulärwerten ausgeführt.

**Hypothese** Je mehr Singulärwerte verwendet werden, desto grösser werden die Überschneidungen
```{r}
SVD_pred <- function(train_data, test_data,singular_value) {

SVD1 <- Recommender(as(train_data, "realRatingMatrix"), "SVD",
  param = list( k = singular_value)
)
PSVD1<- predict(SVD1, as(test_data, "realRatingMatrix"), type = "topNList", n = 15)
return(PSVD1)
}
```

```{r}
# Sample 1
p <- list()
i = 1
for (singular_value in c(10,20,30,40,50)){
  p[[i]] <- intersection_Top15(pIBCF1,SVD_pred(training1,test1,singular_value),paste("SVD mit ",singular_value, " Singulärwerten"),"IBCF","1",TRUE)
  i <- i + 1
}
do.call(grid.arrange,c(p, ncol=2))
```

```{r}
# Sample 2
p <- list()
i = 1
for (singular_value in c(10,20,30,40,50)){
  p[[i]] <- intersection_Top15(pIBCF2,SVD_pred(training2,test2,singular_value),paste("SVD mit ",singular_value, " Singulärwerten"),"IBCF","2",TRUE)
  i <- i + 1
}
do.call(grid.arrange,c(p, ncol=2))
```
**Beobachtung:** Die Überschneidungen sind im allgemeinen nicht gross. Mit steigendem Singulärwert nehmen die Überschneidungen zu. Im Datensatz 1 nehmen sie stärker zu wie im Datensatz 2

**Schlussfolgerung:** Die Hypothese kann somit angenommen werden. Je weniger die Daten komprimiert (mehr Singulärwerte) werden, desto mehr Überschneidungen sind mit dem IBCF Recommender vorhanden.

# Implementierung Top-N Metriken
Die Metriken werden nach folgenden Fomeln implementiert
https://spaces.technik.fhnw.ch/spaces/recommender-systems/beitraege/recommender-system-evaluierung-coverage-und-novelty-1

## Funktion Coverage
```{r}
coverage <- function(model){
predTopN <- as.data.frame(as(model, "matrix"))
predTopN$user <- rownames(predTopN)
predTopN <- pivot_longer(predTopN, cols = -c(user), values_drop_na = TRUE)

return(length(unique(predTopN$name))/700)
}
```

```{r}

calc_IBCF <- function(data,top_n){
IBCF_full1 <- Recommender(as(as.matrix(data), "realRatingMatrix"), "IBCF",
  param = list(normalize = NULL, method = "cosine", k = 30,na_as_zero = TRUE)
)
pIBCF_full1<- predict(IBCF_full1, as(as.matrix(data), "realRatingMatrix"), type = "topNList", n = top_n)
return(pIBCF_full1)
}
```

## Funktion Novelty
```{r}
# calc popularity sample 1
log_popularity1 <- ratings1 %>%
  group_by(movieId) %>%
  summarise(log_pop = log(n()/400))
```

```{r}
# calc popularity sample 2
log_popularity2 <- ratings2%>%
  group_by(movieId)%>%
  summarise(log_pop = log(n()/400))
```

```{r}
novelty <- function(model,log_popularity,topn,num_user = 400){
predTopN <- as.data.frame(as(model, "matrix"))
predTopN$user <- rownames(predTopN)
predTopN <- pivot_longer(predTopN, cols = -c(user), values_drop_na = TRUE) %>%
  rename(movieId = name)
predTopN <- transform(predTopN, movieId = as.numeric(movieId))
pred_with_log <- left_join(predTopN,log_popularity,by = "movieId")
return(-sum(pred_with_log$log_pop)/num_user/topn)
}
```

## Test von den System-Metriken
```{r}
novelty1 = c()
novelty2 = c()
coverage1 = c()
coverage2 = c()
topn = c( 5, 10, 15,20,25,30)
for (TopN in topn){
  novelty1 <- append(novelty1,novelty(calc_IBCF(m_user_item_r1,TopN),log_popularity1,TopN))
  coverage1 <- append(coverage1,coverage(calc_IBCF(m_user_item_r1,TopN)))
  novelty2 <- append(novelty2,novelty(calc_IBCF(m_user_item_r2,TopN),log_popularity2,TopN))
  
  coverage2 <- append(coverage2,coverage(calc_IBCF(m_user_item_r2,TopN)))
  
}
```



```{r}
cov_novel1 <- as.data.frame(list(coverage1,novelty1,topn), col.names = c("cov","novel","topn"))
cov_novel2 <- as.data.frame(list(coverage2,novelty2,topn), col.names = c("cov","novel","topn"))
```

```{r}
ggplot(cov_novel1,aes(topn,cov))+
  geom_point()+
  ylim(0,1) +
  labs(
    title = "Verlauf von Coverage jenach länge der TOP-N Liste",
    x = "Länge Top-N Liste",
    y = "Coverage",
    subtitle = "Datensatz 1"
  ) +
  theme_classic()
```

```{r}
ggplot(cov_novel1,aes(topn,novel))+
  geom_point()+
  ylim(0,2.5) +
  labs(
    title = "Verlauf von Novelty jenach länge der TOP-N Liste",
    x = "Länge Top-N Liste",
    y = "Novelty",
    subtitle = "Datensatz 1"
  ) +
  theme_classic()
```

```{r}
ggplot(cov_novel2,aes(topn,cov))+
  geom_point()+
  ylim(0,1) +
  labs(
    title = "Verlauf von Coverage jenach länge der TOP-N Liste",
    x = "Länge Top-N Liste",
    y = "Coverage",
    subtitle = "Datensatz 2"
  ) +
  theme_classic()
```

```{r}
ggplot(cov_novel2,aes(topn,novel))+
  geom_point()+
  ylim(0,2.5) +
  labs(
    title = "Verlauf von Novelty jenach länge der TOP-N Liste",
    x = "Länge Top-N Liste",
    y = "Novelty",
    subtitle = "Datensatz 2"
  ) +
  theme_classic()
```
**Kurzbeschrieb Coverage**

Die Metrik Coverage zeigt wie Gross der Anteil von allen Filmen ist, die vorgeschlagen werden. Anhand von dieser Metrik kann man gut erkennen, ob die meisten Filmen für einen Vorschlag in Betracht gezogen werden.
Mit dieser Metrik kann nicht getestet werden, wie oft die einzelnen Filme vorgekommen sind. Es könnte immer noch sein, dass ein Film bei allen Top-N Listen vorkommt.

**Kurzbeschrieb Novelty**

Mit dieser Metrik kann aufgezeigt werden, wieviel neues eine Recommender hervorbringt. Durch die Popularity wird ein Bezug auf die Testdaten genommen.

# Wahl des optimalen Recommenders

## 10-Fache Krossvalidierung

Im folgenden wird eine 10-Fache Krossvalidierung. Damit eine Aussage gemacht werden kann, wurde eine minimale Anzahl von 5 Ratings bestimmt. Diese sollten jeweils in den Trainingsdaten vorhanden sein.
```{r}
scheme <-  evaluationScheme(as(as.matrix(m_user_item_r2),"realRatingMatrix"), method="cross-validation",k=10, given=5,goodRating  = 0)
```

## Begründung der Modelle und Metriken

**Modelle:**
In dieser Aufgabe probieren wir die bereits kennengelernten. Damit wir noch ein zusätzliches Modell ausprobieren können werden wir 6 Modelle Prüfen. Als zusätzliches Modell wurde der Recommender Funk SVD ausgewählt. 
Für einen besseren Test, müssten die Hyperparameter der einzelnen Modelle zuerst Trainiert werden. Dies wird aus Zeitgründen nicht gemacht. Trotzdem werden ähnliche Parameter gleich verwendet. Somit werden zum Beispiel beim UBCF und IBCF Recommender jeweils 30 Neighbours verwendet.

**Metriken:**

Als Testmetriken wird Precision, Novelty und Coverage verwendet.

## Analyses des besten Modelles

**Precision**

```{r}
algorithms <- list(
  "user-based CF" = list(name="UBCF", param=list(method="Cosine",
                                                 nn=30
                                                 )),
  "item-based CF" = list(name="IBCF", param=list(k = 30,
                                                 method = "cosine"
                                                 )),
  "Binary user-based CF" = list(name = "IBCF", param = list(k=30,
                                                          method = "jaccard")),
  "Binary item-based CF" = list(name = "UBCF", param = list(nn=30,
                                                          method = "jaccard")),
  "SVD" = list(name = "SVD",param = list(k= 30)),
  
  "Funk SVD" = list(name = "SVDF",param = list(k = 30))
  
  
  )

# run algorithms, predict next n movies
topn <- c(10, 15, 20, 25, 30)
results <- evaluate(scheme, algorithms,type="topNList" , n= topn)
```

```{r}
# Precision extrahieren
alg_names <- names(algorithms)
precision <- as.data.frame({})
for (model in 1:length(alg_names)){
  model_select <- getResults(results[[model]])
  precision_split <- as.data.frame({})
for (split in 1:10){ 
precision_split <- rbind(precision_split,select(as.data.frame(model_select[[split]]),c("precision","n")))
}
precision_split$model <- alg_names[[model]]
precision <- rbind(precision,precision_split)
}

```
```{r}
# Standartabweichung und durchschnitt der 10 kfolds berechnen.
precision <- precision %>%
group_by(model,n)%>%
  summarise(mean_prec = mean(precision),
            sd_prec = sd(precision))
```

```{r}
top_n_movies1 <- user_item_r1%>%
  group_by(movieId)%>%
  summarise(mean_rating = mean(z_rating)) %>%
  arrange(desc(mean_rating))%>%
  head(30)%>%
  rename(name = movieId)
class(top_n_movies1$name) <- "character"

top_n <- top_n_movies1$name
```

```{r}
prec_best_mean <- as.data.frame({})

for (n in topn){
  prec_fold = list()
    for (n_split in 1:10){
      
    pred_movies <- getData(scheme,"unknown",run = n_split)
    pred_movies <- as.data.frame(as(pred_movies,"matrix"))
    pred_movies$username <- rownames(pred_movies)
    pred_movies_long <- pivot_longer(pred_movies, cols = -c(username), values_drop_na = TRUE)
    
    prec <- nrow(pred_movies_long %>%
       filter(name %in% top_n[1:n]))/n/40
    
    prec_fold <- append(prec_fold,prec)

    }
  prec_best_mean <-rbind(prec_best_mean,as.data.frame(list(mean(unlist(prec_fold)),sd(unlist(prec_fold)),n,"pre_best_mean"),col.names = c("mean_prec","sd_prec","n","model")))
  }
```

```{r}
precision <- rbind(precision,prec_best_mean)

precision$type <- "precision"
```


```{r}
p <- list()
i = 1
for (n_value in topn){
  pre_plot <- filter(precision,n == n_value)
plot <- (ggplot(pre_plot, aes(x=model, y= mean_prec)) + 
  geom_point() +
  geom_errorbar(aes(ymin=mean_prec- sd_prec, ymax=mean_prec+sd_prec), width=.2,
                 position=position_dodge(.9))+
  ylim(0,0.2)+
    labs(
    title = paste("Precision von Top -",n_value," listen"),
    x = "Precision",
    y = "Modell"))
   p[[i]] <- plot
   
   i = i + 1
}
do.call(grid.arrange,c(p, ncol=1))
```


**Coverage und Novelty**
Coverage und Novelty von den unterschiedlichen Modellen berechnen.

```{r}
# novelty base model
top_n_movies1 <- top_n_movies1%>%rename(movieId = name)
class(top_n_movies1$movieId) <- "integer"
pred_with_log <- left_join(top_n_movies1
                           ,log_popularity1,by = "movieId")

novelty_best_mean_model =c()
for (n_value in topn){
  novelty_best_mean_model <- append(novelty_best_mean_model,(-sum(head(pred_with_log,n_value)$log_pop)/1/n_value))
}
```
```{r}
# coverage base model
coverage_best_mean_model =c()
for (n_value in topn){
  coverage_best_mean_model <- append(coverage_best_mean_model,n_value/700)
}
```

```{r}
novelty_values = as.data.frame({})
coverage_values = as.data.frame({})
i = 1
for (top in topn){
for (algorithm in algorithms){
  nov_fold = list()
  cov_fold = list()
  for (n_split in 1:10){
    trained_model <- Recommender(getData(scheme,"train",run = n_split), algorithm$name,
  param = algorithm$param
)

# predict model
pred_model <- predict(trained_model, getData(scheme,"unknown",run = n_split), type = "topNList", n = top)
nov_fold <- append(nov_fold,novelty(pred_model,log_popularity2,top,40))
cov_fold <- append(cov_fold,coverage(pred_model))
}
novelty_values <-rbind(novelty_values,as.data.frame(list(mean(unlist(nov_fold)),sd(unlist(nov_fold)),top,alg_names[[i]]),col.names = c("mean_novel","sd_novel","n","model")))
coverage_values <- rbind(coverage_values,as.data.frame(list(mean(unlist(cov_fold)),sd(unlist(cov_fold)),top,alg_names[[i]]),col.names = c("mean_cov","sd_cov","n","model")))
i = i + 1
}}

```


```{r}
p <- list()
i = 1
for (n_value in topn){
  pre_plot <- filter(novelty_values,n == n_value)
plot <- (ggplot(pre_plot, aes(x=model, y= mean_novel)) + 
  geom_point() +
  geom_errorbar(aes(ymin=mean_novel- sd_novel, ymax=mean_novel+sd_novel), width=.2,
                 position=position_dodge(.9))+

    labs(
    title = paste("Novelty von Top -",n_value," listen"),
    subtitle = paste("Novelty Basis Modell: ",round(novelty_best_mean_model[[i]],2)),
    x = "Novelty",
    y = "Modell"))
   p[[i]] <- plot
   
   i = i + 1
}
do.call(grid.arrange,c(p, ncol=1))
```


```{r}
p <- list()
i = 1
for (n_value in topn){
  pre_plot <- filter(coverage_values,n == n_value)
plot <- (ggplot(pre_plot, aes(x=model, y= mean_cov)) + 
  geom_point() +
  geom_errorbar(aes(ymin=mean_cov- sd_cov, ymax=mean_cov+sd_cov), width=.2,
                 position=position_dodge(.9))+

    labs(
    title = paste("Novelty von Top -",n_value," listen"),
    subtitle = paste("Novelty Basis Modell: ",round(coverage_best_mean_model[[i]],2)),
    x = "Novelty",
    y = "Modell"))
   p[[i]] <- plot
   
   i = i + 1
}
do.call(grid.arrange,c(p, ncol=1))
```

## Hyperparameter Trainieren

